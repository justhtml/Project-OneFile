<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gomoku — 3 Players, 1-file</title>
<style>
  :root{--bg:#111;--panel:#0f1720;--muted:#9aa4b2;--accent:#7dd3fc}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
  body{background:linear-gradient(180deg,#071023 0%, #071827 55%);color:#e6eef6;display:flex;gap:16px;padding:18px;box-sizing:border-box}
  .wrap{display:flex;gap:16px;width:100%;align-items:flex-start}
  .left{flex:1;min-width:360px}
  .panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
  h1{margin:6px 0 12px;font-size:18px}
  canvas{width:100%;height:auto;border-radius:8px;background:linear-gradient(180deg,#eef8ff03,#00000000)}
  .controls{display:flex;flex-wrap:wrap;gap:8px}
  label{display:block;font-size:12px;color:var(--muted)}
  input[type=number],select{background:#071428;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:inherit}
  button{background:linear-gradient(180deg,#0ea5e9,#0284c7);border:none;color:#082033;padding:8px 10px;border-radius:8px;font-weight:600;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .status{margin-top:8px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .players{display:flex;gap:8px;margin-top:8px}
  .player{display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px}
  .dot{width:18px;height:18px;border-radius:50%;display:inline-block;box-shadow:0 2px 6px rgba(0,0,0,0.6)}
  .muted{color:var(--muted)}
  .footer{font-size:12px;color:var(--muted);margin-top:10px}
  .right{width:320px}
  .preset{display:flex;gap:8px}
  .small{font-size:13px;padding:6px}
  .kbd{background:#0b2836;padding:4px 6px;border-radius:6px;font-family:monospace}
  @media (max-width:900px){body{padding:12px} .right{display:none}}
</style>
</head>
<body>
  <div class="wrap">
    <div class="left panel">
      <h1>Gomoku — 3 players (1-file)</h1>
      <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px">
        <div style="flex:1">
          <label class="muted">Board</label>
          <div style="display:flex;gap:8px">
            <input id="sizeInput" type="number" min="6" max="40" value="15" style="width:84px" />
            <input id="winInput" type="number" min="3" max="40" value="6" style="width:84px" />
            <button id="applyBtn" class="small">Apply & New</button>
          </div>
          <div class="muted" style="font-size:12px;margin-top:6px">Size: N × N, Win length: connect this many or more.</div>
        </div>
        <div style="width:120px;text-align:right">
          <label class="muted">Controls</label>
          <div style="display:flex;gap:6px;justify-content:flex-end;margin-top:4px">
            <button id="undoBtn" class="ghost small">Undo</button>
            <button id="redoBtn" class="ghost small">Redo</button>
          </div>
        </div>
      </div><div class="panel" style="padding:10px;margin-bottom:8px">
    <canvas id="board" width="720" height="720" style="max-width:100%;height:auto;display:block"></canvas>
    <div class="status" id="status">Initializing...</div>
  </div>

  <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
    <div class="player" id="p1"><span class="dot" style="background:#08121b"></span><div style="font-weight:700">Player 1</div></div>
    <div class="player" id="p2"><span class="dot" style="background:#ffffff"></span><div style="font-weight:700">Player 2</div></div>
    <div class="player" id="p3"><span class="dot" style="background:#d6336c"></span><div style="font-weight:700">Player 3</div></div>
  </div>

  <div class="footer">
    Rules in brief: 3 players. Player 1 places 1 stone on the very first turn only. Every subsequent turn for all players is 2 stones. First to connect <span id="winLenText">6</span> in a row (or more) wins. Click intersections to place.
  </div>
</div>

<div class="right panel">
  <h2 style="margin:0 0 8px 0">Settings & Info</h2>
  <div style="display:grid;grid-template-columns:1fr;gap:8px">
    <div>
      <label class="muted">Stone size (pixels)</label>
      <input id="stoneSize" type="number" min="6" max="40" value="18" />
    </div>
    <div>
      <label class="muted">Grid padding (px)</label>
      <input id="pad" type="number" min="8" max="60" value="36" />
    </div>
    <div>
      <label class="muted">Toggle coordinates</label>
      <select id="coords" >
        <option value="off">Off</option>
        <option value="on">On</option>
      </select>
    </div>
    <div>
      <label class="muted">Turn log</label>
      <div id="log" style="max-height:220px;overflow:auto;padding:8px;background:#071620;border-radius:8px;font-family:monospace;font-size:13px;color:var(--muted)"></div>
    </div>
  </div>

  <div style="margin-top:10px">
    <button id="newBtn">New Game</button>
    <button id="exportBtn" class="ghost">Export as JSON</button>
  </div>

  <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />
  <div style="font-size:13px;color:var(--muted)">How it works:
    <ul style="margin:6px 0 0 18px;padding:0">
      <li>Click a visible intersection to place stone(s).</li>
      <li>You must place the configured number of stones to finish your turn.</li>
      <li>Undo/Redo works per placed stone (each click is recorded).</li>
    </ul>
  </div>
</div>

  </div><script>
// --- State and config ---
let N = 15;
let winLen = 6;
let pad = 36; // padding in pixels
let stoneSize = 18;
let showCoords = false;
const players = [null, {id:1,color:'#08121b',label:'P1'}, {id:2,color:'#ffffff',label:'P2'}, {id:3,color:'#d6336c',label:'P3'}];

let board = [];
let history = []; // list of {r,c,player}
let redoStack = [];
let currentPlayer = 1;
let stonesRemainingThisTurn = 0; // how many stones current player still must place this turn
let gameOver = false;

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

function initBoard(n){
  N = n;
  board = Array.from({length:N},()=>Array(N).fill(0));
}

function setConfigFromUI(){
  const s = parseInt(document.getElementById('sizeInput').value)||15;
  const w = parseInt(document.getElementById('winInput').value)||6;
  const sg = parseInt(document.getElementById('stoneSize').value)||18;
  const p = parseInt(document.getElementById('pad').value)||36;
  N = Math.max(6,Math.min(40,s));
  winLen = Math.max(3,Math.min(40,w));
  stoneSize = Math.max(6,Math.min(40,sg));
  pad = Math.max(8,Math.min(80,p));
  document.getElementById('winLenText').textContent = winLen;
  showCoords = document.getElementById('coords').value === 'on';
}

function newGame(n){
  setConfigFromUI();
  N = n || N;
  initBoard(N);
  history = [];
  redoStack = [];
  currentPlayer = 1;
  stonesRemainingThisTurn = startingStonesFor(currentPlayer, history.length === 0);
  gameOver = false;
  resizeCanvas();
  draw();
  logEl.textContent = '';
  updateStatus();
}

function startingStonesFor(player,isVeryFirstTurn){
  // Player 1 places 1 stone on the very first turn only. Every subsequent turn for all players is 2 stones.
  if(isVeryFirstTurn && player===1) return 1;
  return 2;
}

function resizeCanvas(){
  // square canvas; pick min dimension
  const size = Math.max(420, Math.min(900, Math.floor(Math.min(window.innerWidth*0.6, 820))));
  canvas.width = size;
  canvas.height = size;
}

window.addEventListener('resize',()=>{resizeCanvas(); draw();});

function draw(){
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  // background grid
  ctx.fillStyle = '#e6eef61a';
  ctx.fillRect(0,0,W,H);

  // compute cell
  const cell = (W - pad*2) / (N-1);
  // draw lines
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  for(let i=0;i<N;i++){
    const x = pad + i*cell;
    ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x, W-pad); ctx.stroke();
    const y = pad + i*cell;
    ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(W-pad, y); ctx.stroke();
  }
  // draw intersections (small cross)
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const x = pad + c*cell; const y = pad + r*cell;
      ctx.beginPath(); ctx.arc(x,y,2,0,Math.PI*2); ctx.fill();
    }
  }
  // draw coords if enabled
  if(showCoords){
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.font = Math.max(10, Math.floor(cell*0.25))+'px monospace';
    for(let i=0;i<N;i++){ const x=pad+i*cell; const y=pad-6; ctx.fillText(i+1, x-6,y); const y2=W-pad+14; ctx.fillText(i+1,x-6,y2); }
    for(let i=0;i<N;i++){ const y=pad+i*cell; const x=pad-20; ctx.fillText(i+1, x,y+4); const x2=W-pad+6; ctx.fillText(i+1,x2,y+4);}  
  }

  // draw stones
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const p = board[r][c];
      if(!p) continue;
      const x = pad + c*cell; const y = pad + r*cell;
      drawStone(x,y,players[p].color,stoneSize);
    }
  }
}

function drawStone(x,y,color,size){
  // stone shadow
  ctx.beginPath(); ctx.arc(x+1.8,y+1.8,size/2+1,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fill();
  // stone body
  ctx.beginPath(); ctx.arc(x,y,size/2,0,Math.PI*2); ctx.fillStyle = color; ctx.fill();
  // rim highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.stroke();
}

// input to grid coordinate
function pixelToGrid(px,py){
  const W = canvas.width;
  const cell = (W - pad*2) / (N-1);
  const cx = Math.round((px - pad)/cell);
  const cy = Math.round((py - pad)/cell);
  if(cx<0||cx>=N||cy<0||cy>=N) return null;
  const gx = pad + cx*cell; const gy = pad + cy*cell;
  const d = Math.hypot(px-gx, py-gy);
  if(d > Math.max(12, cell*0.45)) return null; // clicked too far from intersection
  return {r:cy,c:cx};
}

canvas.addEventListener('click', (e)=>{
  if(gameOver) return;
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  const g = pixelToGrid(x,y);
  if(!g) return;
  placeStone(g.r,g.c);
});

function placeStone(r,c){
  if(board[r][c] !== 0) return; // occupied
  if(gameOver) return;
  // if player has stonesRemainingThisTurn <=0 then not expected: advance turn
  if(stonesRemainingThisTurn <= 0){
    // advance first
    advanceTurn();
  }
  // place
  board[r][c] = currentPlayer;
  history.push({r,c,player:currentPlayer});
  redoStack = [];
  stonesRemainingThisTurn -= 1;
  appendLog(`P${currentPlayer} placed at (${r+1},${c+1})`);
  draw();
  // check win after each stone
  const winner = checkWinnerAt(r,c,currentPlayer);
  if(winner){
    gameOver = true;
    updateStatus(`Player ${currentPlayer} wins!`);
    appendLog(`Player ${currentPlayer} wins!`);
    return;
  }
  if(stonesRemainingThisTurn <= 0){
    advanceTurn();
  } else {
    updateStatus(`Player ${currentPlayer} — place ${stonesRemainingThisTurn} more stone(s)`);
  }
}

function advanceTurn(){
  // next player
  currentPlayer = (currentPlayer % 3) + 1;
  stonesRemainingThisTurn = startingStonesFor(currentPlayer, history.length === 0);
  updateStatus(`Player ${currentPlayer} — place ${stonesRemainingThisTurn} stone(s)`);
}

function appendLog(text){
  const t = document.createElement('div'); t.textContent = text; logEl.appendChild(t); logEl.scrollTop = logEl.scrollHeight;
}

function updateStatus(txt){
  if(txt){ statusEl.textContent = txt; return; }
  if(gameOver) return;
  statusEl.textContent = `Player ${currentPlayer} — place ${stonesRemainingThisTurn} stone(s)`;
}

function checkWinnerAt(r,c,player){
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  for(const d of dirs){
    let cnt = 1;
    for(let s=1;s<winLen+5;s++){ // forward
      const rr = r + d[0]*s, cc = c + d[1]*s;
      if(rr<0||rr>=N||cc<0||cc>=N) break;
      if(board[rr][cc]===player) cnt++; else break;
    }
    for(let s=1;s<winLen+5;s++){ // backward
      const rr = r - d[0]*s, cc = c - d[1]*s;
      if(rr<0||rr>=N||cc<0||cc>=N) break;
      if(board[rr][cc]===player) cnt++; else break;
    }
    if(cnt >= winLen) return true;
  }
  return false;
}

// --- Undo / Redo ---
function undo(){
  if(history.length === 0) return;
  const last = history.pop();
  redoStack.push(last);
  // rebuild board and turn state from history
  rebuildFromHistory();
  appendLog(`Undo: removed P${last.player} at (${last.r+1},${last.c+1})`);
}

function redo(){
  if(redoStack.length === 0) return;
  const e = redoStack.pop();
  history.push(e);
  // apply
  rebuildFromHistory();
  appendLog(`Redo: re-applied P${e.player} at (${e.r+1},${e.c+1})`);
}

function rebuildFromHistory(){
  initBoard(N);
  gameOver = false;
  currentPlayer = 1;
  stonesRemainingThisTurn = startingStonesFor(currentPlayer, history.length===0);
  logEl.textContent = '';
  for(const move of history){
    // place as recorded
    board[move.r][move.c] = move.player;
    appendLog(`P${move.player} placed at (${move.r+1},${move.c+1})`);
    // decrease stonesRemainingThisTurn
    stonesRemainingThisTurn -= 1;
    if(checkWinnerAt(move.r,move.c,move.player)){
      gameOver = true;
      currentPlayer = move.player;
      updateStatus(`Player ${move.player} wins!`);
      draw();
      return;
    }
    if(stonesRemainingThisTurn <= 0){
      // advance
      currentPlayer = (currentPlayer % 3) + 1;
      stonesRemainingThisTurn = startingStonesFor(currentPlayer, history.length===0);
    }
  }
  // if history empty, ensure values
  if(history.length === 0){ currentPlayer = 1; stonesRemainingThisTurn = startingStonesFor(1, true);} 
  draw();
  updateStatus();
}

// --- UI wiring ---
document.getElementById('applyBtn').addEventListener('click', ()=>{
  setConfigFromUI(); newGame();
});

document.getElementById('newBtn').addEventListener('click', ()=>{ newGame(); });
document.getElementById('undoBtn').addEventListener('click', ()=>{ undo(); });
document.getElementById('redoBtn').addEventListener('click', ()=>{ redo(); });

document.getElementById('exportBtn').addEventListener('click', ()=>{
  const data = {N,winLen,stoneSize,pad,history};
  const s = JSON.stringify(data, null, 2);
  const blob = new Blob([s],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='gomoku_export.json'; a.click(); URL.revokeObjectURL(url);
});

// init values from UI
(function boot(){
  setConfigFromUI();
  resizeCanvas();
  initBoard(N);
  history = [];
  redoStack = [];
  currentPlayer = 1;
  stonesRemainingThisTurn = startingStonesFor(currentPlayer, true);
  updateStatus();
  draw();
})();

</script></body>
</html>