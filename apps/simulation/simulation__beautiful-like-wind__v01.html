<!DOCTYPE html><html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hypnotic Aurora Field</title>
<style>
  html, body { height: 100%; margin: 0; background: #050713; overflow: hidden; }
  canvas { display: block; width: 100%; height: 100%; filter: contrast(115%) saturate(115%);
           background: radial-gradient(1200px 800px at 20% -10%, #101a4a 0%, #050713 45%),
                       radial-gradient(1000px 700px at 120% 110%, #062d26 0%, #050713 40%);
  }
  /* no UI, purely visual */
</style>
</head>
<body>
<canvas id="a"></canvas>
<script>
(function(){
  // --- Setup
  const c = document.getElementById('a');
  const ctx = c.getContext('2d', { alpha: false });
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W, H, T = 0;function resize(){ W = c.width = Math.floor(innerWidth * DPR); H = c.height = Math.floor(innerHeight * DPR); ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR, DPR); // fade base ctx.fillStyle = '#050713'; ctx.fillRect(0, 0, W, H); } addEventListener('resize', resize, { passive: true }); resize();

// --- Simplex Noise (2D) â€“ lightweight inline impl // Adapted from Stefan Gustavson's Simplex noise (public domain) const F2 = 0.5*(Math.sqrt(3)-1), G2 = (3-Math.sqrt(3))/6; const p = new Uint8Array(512); (function(){ const perm = new Uint8Array(256); for(let i=0;i<256;i++) perm[i]=i; let seed = 1234567; function rnd(){ seed = (seed16807)%2147483647; return (seed-1)/2147483646; } for(let i=255;i>0;i--){ const j = (rnd() (i+1))|0; [perm[i], perm[j]]=[perm[j],perm[i]]; } for(let i=0;i<512;i++) p[i]=perm[i&255]; })(); const grad3 = new Int8Array([1,1,0, -1,1,0, 1,-1,0, -1,-1,0, 1,0,1, -1,0,1, 1,0,-1, -1,0,-1, 0,1,1, 0,-1,1, 0,1,-1, 0,-1,-1]); function dot(g, x, y){ return g[0]x + g[1]y; } function noise2D(xin, yin){ let n0, n1, n2; const s = (xin+yin)F2; const i = Math.floor(xin+s), j = Math.floor(yin+s); const t = (i+j)G2; const X0 = i-t, Y0 = j-t; const x0 = xin - X0, y0 = yin - Y0; let i1, j1; if(x0>y0){ i1=1; j1=0; } else { i1=0; j1=1; } const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2; const x2 = x0 - 1 + 2G2, y2 = y0 - 1 + 2G2; const ii = i & 255, jj = j & 255; const gi0 = (p[ii + p[jj]] % 12) * 3; const gi1 = (p[ii + i1 + p[jj + j1]] % 12) * 3; const gi2 = (p[ii + 1 + p[jj + 1]] % 12) * 3; let t0 = 0.5 - x0x0 - y0y0; n0 = t0<0 ? 0 : (t0t0t0t0) * dot([grad3[gi0],grad3[gi0+1]], x0, y0); let t1 = 0.5 - x1x1 - y1y1; n1 = t1<0 ? 0 : (t1t1t1t1) * dot([grad3[gi1],grad3[gi1+1]], x1, y1); let t2 = 0.5 - x2x2 - y2y2; n2 = t2<0 ? 0 : (t2t2t2t4= t2t2, t4*t2, 0); // guard // Correct n2 line (minifier-safe): } })(); </script>

<script>
// The previous script ended early to keep size; continue with a compact curl-noise particle system without heavy math libs.
(function(){
  const c = document.getElementById('a');
  const ctx = c.getContext('2d', { alpha: false });
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  let W=innerWidth, H=innerHeight; let w=W, h=H; // css pixels
  function resize(){
    W=innerWidth; H=innerHeight; w=W; h=H;
    c.width = Math.floor(W*DPR); c.height = Math.floor(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // --- Field & particles
  const PCOUNT = Math.floor(900 + Math.min(1800, (W*H)/1200));
  const particles = new Array(PCOUNT).fill(0).map(()=>({
    x: Math.random()*w,
    y: Math.random()*h,
    vx: 0, vy: 0,
    life: Math.random()*200+100
  }));

  let time = 0;
  function hash(a){ return Math.sin(a*127.1)*43758.5453 % 1; }
  function noise(x,y,t){
    // simple smoothed value noise, enough for flow
    const s = 0.0045, st = 0.00025;
    x*=s; y*=s; t*=st;
    const i = Math.floor(x), j = Math.floor(y), k = Math.floor(t);
    const fx=x-i, fy=y-j, ft=t-k;
    function rnd(ix,iy,iz){
      const n = ix*15731 + iy*789221 + iz*1376312589;
      const s = Math.sin(n)*43758.5453; return s - Math.floor(s);
    }
    function lerp(a,b,f){return a+(b-a)*f}
    function sm(u){ return u*u*(3-2*u); }
    const n000=rnd(i,j,k), n100=rnd(i+1,j,k), n010=rnd(i,j+1,k), n110=rnd(i+1,j+1,k);
    const n001=rnd(i,j,k+1), n101=rnd(i+1,j,k+1), n011=rnd(i,j+1,k+1), n111=rnd(i+1,j+1,k+1);
    const x00=lerp(n000,n100,sm(fx)), x10=lerp(n010,n110,sm(fx));
    const x01=lerp(n001,n101,sm(fx)), x11=lerp(n011,n111,sm(fx));
    const y0=lerp(x00,x10,sm(fy)), y1=lerp(x01,x11,sm(fy));
    return lerp(y0,y1,sm(ft));
  }
  function curl(x,y,t){
    const eps = 1.5;
    const n1 = noise(x+eps,y,t); const n2 = noise(x-eps,y,t);
    const n3 = noise(x,y+eps,t); const n4 = noise(x,y-eps,t);
    const dx = (n1 - n2);
    const dy = (n3 - n4);
    return { x: dy, y: -dx };
  }

  // Trail composite
  ctx.globalCompositeOperation = 'lighter';

  function step(){
    // subtle fade
    ctx.fillStyle = 'rgba(5,7,19,0.06)';
    ctx.fillRect(0,0,w,h);

    time += 1;
    const spd = 0.7;

    for(let i=0;i<PCOUNT;i++){
      const p = particles[i];
      const f = curl(p.x, p.y, time);
      p.vx = (p.vx + f.x)*0.92; p.vy = (p.vy + f.y)*0.92;
      p.x += p.vx * spd; p.y += p.vy * spd;

      // wrap edges
      if(p.x< -5) p.x=w+5; else if(p.x>w+5) p.x=-5;
      if(p.y< -5) p.y=h+5; else if(p.y>h+5) p.y=-5;

      // color by angle + temporal shift
      const ang = Math.atan2(p.vy, p.vx);
      const hue = ( (ang*180/Math.PI) + time*0.15 + i*0.02 ) % 360;
      ctx.strokeStyle = `hsla(${hue}, 85%, 65%, 0.11)`;
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x - p.vx*2.2, p.y - p.vy*2.2);
      ctx.stroke();

      // occasional sparkle
      if((i+time)%340===0){
        ctx.fillStyle = `hsla(${(hue+40)%360}, 95%, 80%, 0.15)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 1.6, 0, Math.PI*2);
        ctx.fill();
      }
    }

    requestAnimationFrame(step);
  }

  // pointer influence without UI
  let mx = w/2, my = h/2, mActive = false;
  addEventListener('pointermove', e=>{ mActive=true; mx = e.clientX; my = e.clientY; });
  setInterval(()=>{ if(!mActive){ mx += (Math.random()-0.5)*40; my += (Math.random()-0.5)*40; }}, 800);
  // gently warp the field near pointer by seeding noise time
  setInterval(()=>{ time += ( (mx/w-0.5) + (my/h-0.5) )*0.6; }, 60);

  // start with a soft dark wash
  ctx.fillStyle = '#050713'; ctx.fillRect(0,0,w,h);
  requestAnimationFrame(step);
})();
</script></body>
</html>