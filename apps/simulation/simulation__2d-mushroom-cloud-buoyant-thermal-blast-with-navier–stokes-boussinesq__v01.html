<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Mushroom Cloud (Buoyant Blast)</title>
  <style>
    body {
      margin: 0;
      background: #050609;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
    }

    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      padding: 1rem;
    }

    canvas {
      border-radius: 16px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.8);
      image-rendering: pixelated;
      background: #000;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: center;
      align-items: center;
      font-size: 0.85rem;
    }

    .controls label {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      cursor: pointer;
      font-weight: 600;
      background: #f97316;
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }

    input[type="range"] {
      cursor: pointer;
    }

    h1 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #fed7aa;
    }

    small {
      opacity: 0.7;
      font-size: 0.75rem;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>2D Mushroom Cloud</h1>
    <small>Buoyant thermal blast with Navier–Stokes (Boussinesq)</small>
    <canvas id="fluid" width="400" height="400"></canvas>
    <div class="controls">
      <button id="blastBtn">Blast again</button>
      <label>
        Buoyancy
        <input id="buoyancySlider" type="range" min="0" max="60" value="35" />
      </label>
      <label>
        Viscosity
        <input id="viscositySlider" type="range" min="0" max="30" value="3" />
      </label>
      <label>
        Diffusion
        <input id="diffSlider" type="range" min="0" max="40" value="10" />
      </label>
    </div>
  </div>

  <script>
    // ---------------------------
    // Grid + helper functions
    // ---------------------------
    const NX = 90;    // grid cells in x
    const NY = 90;    // grid cells in y
    const ITER = 18;  // iterations for Poisson solves

    const canvas = document.getElementById("fluid");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const imgData = ctx.createImageData(canvas.width, canvas.height);

    const blastBtn = document.getElementById("blastBtn");
    const buoyancySlider = document.getElementById("buoyancySlider");
    const viscositySlider = document.getElementById("viscositySlider");
    const diffSlider = document.getElementById("diffSlider");

    const size = (NX + 2) * (NY + 2); // with padding

    // Fields
    let u = new Float32Array(size);
    let v = new Float32Array(size);
    let u_prev = new Float32Array(size);
    let v_prev = new Float32Array(size);

    let T = new Float32Array(size);
    let T_prev = new Float32Array(size);

    let p = new Float32Array(size);
    let div = new Float32Array(size);

    const T_ambient = 0.0;
    let dt = 0.05;

    function IX(i, j) {
      return i + (NX + 2) * j;
    }

    function clearArray(arr) {
      arr.fill(0);
    }

    // ---------------------------
    // Boundary conditions
    // ---------------------------
    function set_bnd(b, x) {
      for (let i = 1; i <= NX; i++) {
        x[IX(i, 0)]      = b === 2 ? -x[IX(i, 1)]    : x[IX(i, 1)];
        x[IX(i, NY + 1)] = b === 2 ? -x[IX(i, NY)]   : x[IX(i, NY)];
      }
      for (let j = 1; j <= NY; j++) {
        x[IX(0, j)]      = b === 1 ? -x[IX(1, j)]    : x[IX(1, j)];
        x[IX(NX + 1, j)] = b === 1 ? -x[IX(NX, j)]   : x[IX(NX, j)];
      }

      x[IX(0, 0)]               = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
      x[IX(0, NY + 1)]          = 0.5 * (x[IX(1, NY + 1)] + x[IX(0, NY)]);
      x[IX(NX + 1, 0)]          = 0.5 * (x[IX(NX, 0)] + x[IX(NX + 1, 1)]);
      x[IX(NX + 1, NY + 1)]     = 0.5 * (x[IX(NX, NY + 1)] + x[IX(NX + 1, NY)]);
    }

    // ---------------------------
    // Linear solver (Gauss–Seidel)
    // ---------------------------
    function lin_solve(b, x, x0, a, c) {
      const cInv = 1.0 / c;
      for (let k = 0; k < ITER; k++) {
        for (let j = 1; j <= NY; j++) {
          for (let i = 1; i <= NX; i++) {
            x[IX(i, j)] = (
              x0[IX(i, j)] +
              a * (
                x[IX(i - 1, j)] + x[IX(i + 1, j)] +
                x[IX(i, j - 1)] + x[IX(i, j + 1)]
              )
            ) * cInv;
          }
        }
        set_bnd(b, x);
      }
    }

    // ---------------------------
    // Diffusion
    // ---------------------------
    function diffuse(b, x, x0, diff, dt) {
      const a = dt * diff * NX * NY;
      lin_solve(b, x, x0, a, 1 + 4 * a);
    }

    // ---------------------------
    // Advection
    // ---------------------------
    function advect(b, d, d0, u, v, dt) {
      const dt0x = dt * NX;
      const dt0y = dt * NY;

      for (let j = 1; j <= NY; j++) {
        for (let i = 1; i <= NX; i++) {
          let x = i - dt0x * u[IX(i, j)];
          let y = j - dt0y * v[IX(i, j)];

          if (x < 0.5) x = 0.5;
          if (x > NX + 0.5) x = NX + 0.5;
          if (y < 0.5) y = 0.5;
          if (y > NY + 0.5) y = NY + 0.5;

          const i0 = Math.floor(x);
          const i1 = i0 + 1;
          const j0 = Math.floor(y);
          const j1 = j0 + 1;

          const s1 = x - i0;
          const s0 = 1 - s1;
          const t1 = y - j0;
          const t0 = 1 - t1;

          d[IX(i, j)] =
            s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
            s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
        }
      }
      set_bnd(b, d);
    }

    // ---------------------------
    // Projection
    // ---------------------------
    function project(u, v, p, div) {
      const h = 1.0 / NX;

      for (let j = 1; j <= NY; j++) {
        for (let i = 1; i <= NX; i++) {
          div[IX(i, j)] = -0.5 * h * (
            u[IX(i + 1, j)] - u[IX(i - 1, j)] +
            v[IX(i, j + 1)] - v[IX(i, j - 1)]
          );
          p[IX(i, j)] = 0;
        }
      }
      set_bnd(0, div);
      set_bnd(0, p);

      lin_solve(0, p, div, 1, 4);

      for (let j = 1; j <= NY; j++) {
        for (let i = 1; i <= NX; i++) {
          u[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) / h;
          v[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) / h;
        }
      }

      set_bnd(1, u);
      set_bnd(2, v);
    }

    // ---------------------------
    // Add source
    // ---------------------------
    function add_source(x, s, dt) {
      for (let i = 0; i < size; i++) {
        x[i] += dt * s[i];
      }
    }

    // ---------------------------
    // Velocity step
    // ---------------------------
    function vel_step(u, v, u0, v0, visc, dt) {
      add_source(u, u0, dt);
      add_source(v, v0, dt);

      [u, u0] = [u0, u];
      diffuse(1, u, u0, visc, dt);

      [v, v0] = [v0, v];
      diffuse(2, v, v0, visc, dt);

      project(u, v, p, div);

      [u, u0] = [u0, u];
      [v, v0] = [v0, v];

      advect(1, u, u0, u0, v0, dt);
      advect(2, v, v0, u0, v0, dt);

      project(u, v, p, div);
    }

    // ---------------------------
    // Temperature step
    // ---------------------------
    function temp_step(T, T0, diff, dt) {
      add_source(T, T0, dt);

      [T, T0] = [T0, T];
      diffuse(0, T, T0, diff, dt);

      [T, T0] = [T0, T];
      advect(0, T, T0, u, v, dt);

      set_bnd(0, T);
    }

    // ---------------------------
    // Buoyancy (Boussinesq)
    // ---------------------------
    function apply_buoyancy() {
      const buoyancy = parseFloat(buoyancySlider.value) / 800.0;
      for (let j = 1; j <= NY; j++) {
        for (let i = 1; i <= NX; i++) {
          const idx = IX(i, j);
          const t = T[idx];
          const f = buoyancy * (t - T_ambient);
          v[idx] -= f; // up is negative
        }
      }
    }

    // ---------------------------
    // Blast initial condition
    // ---------------------------
    function createBlast() {
      clearArray(u);
      clearArray(v);
      clearArray(u_prev);
      clearArray(v_prev);
      clearArray(T);
      clearArray(T_prev);
      clearArray(p);
      clearArray(div);

      const cx = Math.floor(NX / 2);
      const cy = NY - 12;      // near bottom
      const radiusInner = 8;   // hot core
      const radiusOuter = 13;  // shock/roll-up region

      const baseTemp = 60.0;
      const upVel = 12.0;
      const radialScale = 4.0;

      for (let j = -radiusOuter; j <= radiusOuter; j++) {
        for (let i = -radiusOuter; i <= radiusOuter; i++) {
          const x = cx + i;
          const y = cy + j;
          if (x < 1 || x > NX || y < 1 || y > NY) continue;

          const r2 = i * i + j * j;
          if (r2 <= radiusOuter * radiusOuter) {
            const idx = IX(x, y);

            // Temperature profile: hotter in the center, fades outward
            const r = Math.sqrt(r2);
            const tFactor = Math.max(0, 1 - r / radiusOuter);
            T[idx] = baseTemp * tFactor;

            // Strong upward push in the center
            if (r2 <= radiusInner * radiusInner) {
              v[idx] -= upVel * (1 - r / radiusInner);
            }

            // Outward radial velocity in a thin ring → helps form the "cap"
            if (r2 > radiusInner * radiusInner && r2 <= radiusOuter * radiusOuter) {
              const nx = i / (r + 1e-5);
              const ny = j / (r + 1e-5);
              u[idx] += radialScale * nx;
              v[idx] += radialScale * ny * 0.6; // mostly horizontal push
            }
          }
        }
      }
    }

    // ---------------------------
    // Visualization (temperature → "nuke" colormap)
    // ---------------------------
    function draw() {
      const w = canvas.width;
      const h = canvas.height;
      const data = imgData.data;

      for (let py = 0; py < h; py++) {
        const gy = Math.floor((py / h) * NY) + 1;
        for (let px = 0; px < w; px++) {
          const gx = Math.floor((px / w) * NX) + 1;
          const idxGrid = IX(gx, gy);

          let t = T[idxGrid];
          // Normalize and clamp
          t = t / 60.0;   // scale against blast temperature
          t = Math.max(0, Math.min(1, t));

          // "Nuclear" palette: dark → deep orange → yellow → pale white/gray
          let r, g, b;
          if (t < 0.25) {
            // dark brownish
            const k = t / 0.25;
            r = 40 + 80 * k;
            g = 20 + 30 * k;
            b = 20 + 30 * k;
          } else if (t < 0.5) {
            const k = (t - 0.25) / 0.25;
            r = 120 + 80 * k;
            g = 50 + 100 * k;
            b = 30 * (1 - k);
          } else if (t < 0.8) {
            const k = (t - 0.5) / 0.3;
            r = 200 + 55 * k;
            g = 150 + 80 * k;
            b = 30 + 40 * (1 - k);
          } else {
            const k = (t - 0.8) / 0.2;
            r = 255;
            g = 230 + 25 * (1 - k);
            b = 180 + 50 * (1 - k);
          }

          const idx = 4 * (px + py * w);
          data[idx]     = r;
          data[idx + 1] = g;
          data[idx + 2] = b;
          data[idx + 3] = t > 0.02 ? 255 : 0; // faint transparency at edges
        }
      }

      ctx.putImageData(imgData, 0, 0);
    }

    // ---------------------------
    // Main loop
    // ---------------------------
    function step() {
      const visc = parseFloat(viscositySlider.value) / 1000.0;
      const diffT = parseFloat(diffSlider.value) / 10000.0;

      // No continuous heating here — pure blast evolution.
      clearArray(T_prev);
      temp_step(T, T_prev, diffT, dt);

      apply_buoyancy();

      clearArray(u_prev);
      clearArray(v_prev);
      vel_step(u, v, u_prev, v_prev, visc, dt);

      draw();
      requestAnimationFrame(step);
    }

    blastBtn.addEventListener("click", createBlast);

    // Mouse: inject extra heat to "grow" the cap manually if you want
    canvas.addEventListener("mousemove", (e) => {
      if (e.buttons !== 1) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const gx = Math.floor((x / canvas.width) * NX) + 1;
      const gy = Math.floor((y / canvas.height) * NY) + 1;

      const radius = 4;
      for (let j = -radius; j <= radius; j++) {
        for (let i = -radius; i <= radius; i++) {
          const xx = gx + i;
          const yy = gy + j;
          if (xx < 1 || xx > NX || yy < 1 || yy > NY) continue;
          if (i * i + j * j <= radius * radius) {
            const idx = IX(xx, yy);
            T[idx] += 20.0;
          }
        }
      }
    });

    // Start with one blast
    createBlast();
    requestAnimationFrame(step);
  </script>
</body>
</html>
