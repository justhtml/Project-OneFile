<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>4D Tesseract Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            color: white;
            background-color: #111;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #4fc3f7;
        }
        .key {
            display: inline-block;
            background: #333;
            padding: 3px 6px;
            margin: 2px;
            border-radius: 3px;
            font-family: monospace;
        }
        .dimension-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>4D Tesseract Explorer</h1>
        <p>Navigate the 3D world with WASD and mouse. Manipulate the 4D tesseract with additional controls below.</p>
        <p>Current 4D rotation: <span id="rotation-info">0, 0, 0, 0</span></p>
    </div>
    
    <div id="controls">
        <h1>Controls</h1>
        <div>
            <strong>Movement:</strong> <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span>
            <span class="key">Space</span> <span class="key">Shift</span>
        </div>
        <div class="dimension-controls">
            <strong>4D Rotation:</strong><br>
            XY plane: <span class="key">1</span> <span class="key">2</span><br>
            XZ plane: <span class="key">3</span> <span class="key">4</span><br>
            XW plane: <span class="key">5</span> <span class="key">6</span><br>
            YZ plane: <span class="key">7</span> <span class="key">8</span><br>
            YW plane: <span class="key">9</span> <span class="key">0</span><br>
            ZW plane: <span class="key">-</span> <span class="key">=</span>
        </div>
        <div>
            <strong>Reset:</strong> <span class="key">R</span>
        </div>
    </div>
    
    <div id="loading">Loading 4D world...</div>
    
    <script>
        window.addEventListener('load', init);
        
        let scene, camera, renderer, controls;
        let tesseractLines = [];
        let rotation4D = { xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0 };
        let rotationSpeed = 0.02;
        let autoRotate = false;
        let keys = {};
        let movementSpeed = 0.2;
        
        function init() {
            document.getElementById('loading').style.display = 'none';
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);
            addStars();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            createTesseract();
            
            scene.add(new THREE.AmbientLight(0x404040));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(1, 1, 1);
            scene.add(dirLight);
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => keys[e.key] = true);
            window.addEventListener('keyup',   (e) => keys[e.key] = false);
            
            animate();
        }
        
        function addStars() {
            const starsGeom = new THREE.BufferGeometry();
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.8 });
            const verts = [];
            for (let i = 0; i < 1000; i++) {
                verts.push(
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000
                );
            }
            starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
            scene.add(new THREE.Points(starsGeom, starMat));
        }
        
        function createTesseract() {
            const verts4D = [];
            for (let i = 0; i < 16; i++) {
                verts4D.push([
                    (i & 1) ? 1 : -1,
                    (i & 2) ? 1 : -1,
                    (i & 4) ? 1 : -1,
                    (i & 8) ? 1 : -1
                ]);
            }
            const edges = [];
            for (let i = 0; i < 16; i++) {
                for (let j = i + 1; j < 16; j++) {
                    let diff = 0;
                    for (let k = 0; k < 4; k++) if (verts4D[i][k] !== verts4D[j][k]) diff++;
                    if (diff === 1) edges.push([i, j]);
                }
            }
            
            const mat = new THREE.LineBasicMaterial({ color: 0x4fc3f7 });
            const proj = project4Dto3D(verts4D);
            
            edges.forEach(edge => {
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute([
                    ...proj[edge[0]],
                    ...proj[edge[1]]
                ], 3));
                const line = new THREE.Line(geom, mat);
                scene.add(line);
                tesseractLines.push(line);
            });
        }
        
        function project4Dto3D(v4d) {
            const v3d = [];
            v4d.forEach(v => {
                let [x, y, z, w] = v;
                
                // XY
                let c = Math.cos(rotation4D.xy), s = Math.sin(rotation4D.xy);
                [x, y] = [x * c - y * s, x * s + y * c];
                // XZ
                c = Math.cos(rotation4D.xz); s = Math.sin(rotation4D.xz);
                [x, z] = [x * c - z * s, x * s + z * c];
                // XW
                c = Math.cos(rotation4D.xw); s = Math.sin(rotation4D.xw);
                [x, w] = [x * c - w * s, x * s + w * c];
                // YZ
                c = Math.cos(rotation4D.yz); s = Math.sin(rotation4D.yz);
                [y, z] = [y * c - z * s, y * s + z * c];
                // YW
                c = Math.cos(rotation4D.yw); s = Math.sin(rotation4D.yw);
                [y, w] = [y * c - w * s, y * s + w * c];
                // ZW
                c = Math.cos(rotation4D.zw); s = Math.sin(rotation4D.zw);
                [z, w] = [z * c - w * s, z * s + w * c];
                
                const dist = 5, scale = dist / (dist + w);
                v3d.push([x * scale, y * scale, z * scale]);
            });
            return v3d;
        }
        
        function updateTesseract() {
            // Rotation controls
            if (keys['1']) rotation4D.xy += rotationSpeed;
            if (keys['2']) rotation4D.xy -= rotationSpeed;
            if (keys['3']) rotation4D.xz += rotationSpeed;
            if (keys['4']) rotation4D.xz -= rotationSpeed;
            if (keys['5']) rotation4D.xw += rotationSpeed;
            if (keys['6']) rotation4D.xw -= rotationSpeed;
            if (keys['7']) rotation4D.yz += rotationSpeed;
            if (keys['8']) rotation4D.yz -= rotationSpeed;
            if (keys['9']) rotation4D.yw += rotationSpeed;
            if (keys['0']) rotation4D.yw -= rotationSpeed;
            if (keys['-']) rotation4D.zw += rotationSpeed;
            if (keys['=']) rotation4D.zw -= rotationSpeed;
            if (keys['r'] || keys['R']) {
                rotation4D = { xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0 };
            }
            
            // Auto-rotate
            if (autoRotate && !Object.values(keys).some(v => v)) {
                rotation4D.xy += rotationSpeed * 0.2;
                rotation4D.zw += rotationSpeed * 0.1;
            }
            
            // Update info text
            document.getElementById('rotation-info').textContent =
                `XY: ${rotation4D.xy.toFixed(2)}, XZ: ${rotation4D.xz.toFixed(2)}, ` +
                `XW: ${rotation4D.xw.toFixed(2)}, YZ: ${rotation4D.yz.toFixed(2)}, ` +
                `YW: ${rotation4D.yw.toFixed(2)}, ZW: ${rotation4D.zw.toFixed(2)}`;
            
            // Re-project and update lines
            const verts4D = [];
            for (let i = 0; i < 16; i++) {
                verts4D.push([
                    (i & 1) ? 1 : -1,
                    (i & 2) ? 1 : -1,
                    (i & 4) ? 1 : -1,
                    (i & 8) ? 1 : -1
                ]);
            }
            const proj = project4Dto3D(verts4D);
            
            let idx = 0;
            for (let i = 0; i < 16; i++) {
                for (let j = i + 1; j < 16; j++) {
                    let diff = 0;
                    for (let k = 0; k < 4; k++) if (verts4D[i][k] !== verts4D[j][k]) diff++;
                    if (diff === 1) {
                        const line = tesseractLines[idx++];
                        const pos = [...proj[i], ...proj[j]];
                        line.geometry.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                    }
                }
            }
        }
        
        function handleMovement() {
            const dir = new THREE.Vector3();
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right   = new THREE.Vector3(-1, 0, 0).applyQuaternion(camera.quaternion);
            
            if (keys['w']) dir.add(forward);
            if (keys['s']) dir.sub(forward);
            if (keys['a']) dir.add(right);
            if (keys['d']) dir.sub(right);
            if (keys[' ']) dir.y += 1;
            if (keys['Shift']) dir.y -= 1;
            
            if (dir.length() > 0) {
                dir.normalize();
                camera.position.addScaledVector(dir, movementSpeed);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            updateTesseract();
            handleMovement();
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>