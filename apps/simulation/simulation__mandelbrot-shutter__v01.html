<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mandelbrot ‚Äì Buttons + Joystick (Single HTML)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark; --panel: rgba(0,0,0,.55); --fg:#eee; }
  html, body { margin:0; height:100%; overflow:hidden; background:#000; }
  canvas#c { display:block; width:100vw; height:100vh; touch-action:none; }

  /* Control panel */
  #ui {
    position: fixed; top: 12px; left: 12px; z-index: 20;
    background: var(--panel); color: var(--fg); font: 12px/1.3 system-ui, sans-serif;
    padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(4px);
    box-shadow: 0 2px 10px rgba(0,0,0,.35);
    user-select: none;
  }
  #ui h1 { margin:0 0 6px 0; font: 600 14px system-ui, sans-serif; }
  #ui .row { display:flex; gap:6px; flex-wrap:wrap; align-items:center; margin:6px 0; }
  button, .mini {
    border:1px solid #333; background:#1b1b1b; color:#ddd; border-radius:8px;
    padding:6px 10px; cursor:pointer;
  }
  button:active { transform: translateY(1px); }
  input[type=range]{ width:180px; }
  #zoomTxt { font-variant-numeric: tabular-nums; }

  /* D-pad arrows */
  .pad { display:grid; grid-template-columns:32px 32px 32px; gap:6px; }
  .pad button { width:32px; height:32px; padding:0; font-weight:700; }

  /* Joystick */
  #joyWrap {
    position: fixed; right: 12px; bottom: 12px; z-index: 20;
    width: 160px; height: 160px; display:flex; align-items:center; justify-content:center;
    background: var(--panel); border-radius: 14px; backdrop-filter: blur(4px);
    box-shadow: 0 2px 10px rgba(0,0,0,.35);
  }
  #joy {
    position: relative; width: 120px; height: 120px; border-radius: 50%;
    background: radial-gradient(ellipse at center, #101010, #0a0a0a);
    border:1px solid #333; touch-action:none;
  }
  #knob {
    position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
    width: 44px; height: 44px; border-radius:50%;
    background: #222; border:2px solid #666; box-shadow: inset 0 0 6px rgba(255,255,255,.06);
    pointer-events:none;
  }
  #hint { opacity:.8; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- LEFT PANEL -->
<div id="ui">
  <h1>Mandelbrot</h1>
  <div class="row">Zoom: <span id="zoomTxt">1√ó</span></div>
  <div class="row">
    <button id="zin">Ôºã</button>
    <button id="zout">Ôºç</button>
    <button id="reset">Reset</button>
  </div>
  <div class="row">
    <label>Max iter</label>
    <input id="iter" type="range" min="50" max="2000" value="500">
    <span class="mini" id="iterVal">500</span>
  </div>
  <div class="row">
    <label><input id="smooth" type="checkbox" checked> Smooth coloring</label>
  </div>

  <div class="row" style="margin-top:8px;">Move</div>
  <div class="pad">
    <div></div><button id="up">‚ñ≤</button><div></div>
    <button id="left">‚óÄ</button><div></div><button id="right">‚ñ∂</button>
    <div></div><button id="down">‚ñº</button><div></div>
  </div>

  <div id="hint" class="row">üñ±Ô∏è Scroll to zoom ‚Ä¢ Drag to pan ‚Ä¢ Dbl-click reset ‚Ä¢ Arrow keys move</div>
</div>

<!-- RIGHT JOYSTICK -->
<div id="joyWrap">
  <div id="joy">
    <div id="knob"></div>
  </div>
</div>

<script>
  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  function fit() {
    const dpr = Math.max(1, devicePixelRatio || 1);
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
  }
  fit();
  addEventListener('resize', () => { fit(); updateZoomText(); requestRender(); });

  // ===== View state =====
  let centerX = -0.5, centerY = 0;
  let scale = Math.min(canvas.width, canvas.height) / 3.2; // px per complex unit
  function updateZoomText(){
    const base = Math.min(canvas.width, canvas.height) / 3.2;
    const z = scale / base;
    document.getElementById('zoomTxt').textContent = (z>=1 ? z.toFixed(2) : z.toPrecision(2)) + '√ó';
  }
  updateZoomText();

  // ===== Controls =====
  const iterSlider = document.getElementById('iter');
  const iterVal = document.getElementById('iterVal');
  const smoothChk = document.getElementById('smooth');
  let MAX_ITER = +iterSlider.value;
  iterSlider.addEventListener('input', () => { MAX_ITER = +iterSlider.value; iterVal.textContent = MAX_ITER; requestRender(); });
  smoothChk.addEventListener('change', requestRender);

  // Buttons: zoom/pan/reset
  const ZOOM_STEP = 1.25;
  const PAN_STEP = () => 80/scale; // complex-units per click; scales with zoom
  document.getElementById('zin').onclick  = () => { zoomAt(canvas.width/2, canvas.height/2, ZOOM_STEP); };
  document.getElementById('zout').onclick = () => { zoomAt(canvas.width/2, canvas.height/2, 1/ZOOM_STEP); };
  document.getElementById('reset').onclick= () => { centerX=-0.5; centerY=0; scale=Math.min(canvas.width, canvas.height)/3.2; updateZoomText(); requestRender(); };

  document.getElementById('up').onclick    = () => { centerY -= PAN_STEP(); requestRender(); };
  document.getElementById('down').onclick  = () => { centerY += PAN_STEP(); requestRender(); };
  document.getElementById('left').onclick  = () => { centerX -= PAN_STEP(); requestRender(); };
  document.getElementById('right').onclick = () => { centerX += PAN_STEP(); requestRender(); };

  // Keyboard arrows to pan; +/- to zoom
  addEventListener('keydown', (e)=>{
    if (e.key === 'ArrowUp')   { centerY -= PAN_STEP(); requestRender(); }
    if (e.key === 'ArrowDown') { centerY += PAN_STEP(); requestRender(); }
    if (e.key === 'ArrowLeft') { centerX -= PAN_STEP(); requestRender(); }
    if (e.key === 'ArrowRight'){ centerX += PAN_STEP(); requestRender(); }
    if (e.key === '+' || e.key === '=') { zoomAt(canvas.width/2, canvas.height/2, ZOOM_STEP); }
    if (e.key === '-' || e.key === '_') { zoomAt(canvas.width/2, canvas.height/2, 1/ZOOM_STEP); }
  });

  // Mouse interactions: zoom at cursor, drag to pan, double-click reset
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, devicePixelRatio || 1);
    const px = (e.clientX - rect.left) * dpr;
    const py = (e.clientY - rect.top)  * dpr;
    const z = Math.pow(1.2, -e.deltaY/100);
    zoomAt(px, py, z);
  }, { passive:false });

  let dragging = false, lastX = 0, lastY = 0;
  canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
  addEventListener('mouseup', () => dragging = false);
  addEventListener('mousemove', e => {
    if (!dragging) return;
    const dpr = Math.max(1, devicePixelRatio || 1);
    centerX -= (e.clientX - lastX) * dpr / scale;
    centerY -= (e.clientY - lastY) * dpr / scale;
    lastX = e.clientX; lastY = e.clientY;
    requestRender();
  });
  canvas.addEventListener('dblclick', () => { centerX=-0.5; centerY=0; scale=Math.min(canvas.width, canvas.height)/3.2; updateZoomText(); requestRender(); });

  function zoomAt(px, py, factor){
    // Complex coord under pixel BEFORE zoom
    const re = centerX + (px - canvas.width/2) / scale;
    const im = centerY + (py - canvas.height/2) / scale;
    scale *= factor;
    // Keep that complex coord under the same pixel AFTER zoom
    centerX = re - (px - canvas.width/2) / scale;
    centerY = im - (py - canvas.height/2) / scale;
    updateZoomText();
    requestRender();
  }

  // ===== Joystick (right corner) =====
  const joy = document.getElementById('joy');
  const knob = document.getElementById('knob');
  const JOY_R = 60;           // radius of pad (px)
  const KNOB_R = 22;          // radius of knob (px)
  let joyActive = false, joyVec = {x:0, y:0};

  function setKnob(dx, dy){
    knob.style.left = (50 + (dx / JOY_R) * 50) + '%';
    knob.style.top  = (50 + (dy / JOY_R) * 50) + '%';
  }
  setKnob(0,0);

  function joyStart(clientX, clientY){
    const rect = joy.getBoundingClientRect();
    const x = clientX - (rect.left + rect.width/2);
    const y = clientY - (rect.top + rect.height/2);
    const len = Math.hypot(x,y) || 1;
    const clamped = Math.min(len, JOY_R - KNOB_R);
    joyVec.x = (x/len) * clamped;
    joyVec.y = (y/len) * clamped;
    setKnob(joyVec.x, joyVec.y);
    joyActive = true;
  }
  function joyMove(clientX, clientY){
    if (!joyActive) return;
    joyStart(clientX, clientY);
  }
  function joyEnd(){
    joyActive = false;
    joyVec.x = 0; joyVec.y = 0;
    setKnob(0,0);
  }

  // Pointer events for mouse/touch
  joy.addEventListener('pointerdown', e => { joy.setPointerCapture(e.pointerId); joyStart(e.clientX, e.clientY); });
  joy.addEventListener('pointermove',  e => joyMove(e.clientX, e.clientY));
  joy.addEventListener('pointerup',    joyEnd);
  joy.addEventListener('pointercancel',joyEnd);
  joy.addEventListener('pointerleave', joyEnd);

  // Apply joystick vector continuously (frame loop)
  function applyJoystick(dt){
    if (!joyActive) return;
    // Speed in complex units per second; scales with zoom
    const base = 300 / scale;   // tweak for feel
    const vx = (joyVec.x / (JOY_R - KNOB_R)) * base;
    const vy = (joyVec.y / (JOY_R - KNOB_R)) * base;
    centerX += vx * dt;
    centerY += vy * dt;
    requestRender();
  }

  // ===== Coloring =====
  function hsvToRgb(h,s,v){
    h = ((h%360)+360)%360; const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
    let r=0,g=0,b=0;
    if (h<60){r=c;g=x;} else if (h<120){r=x;g=c;}
    else if (h<180){g=c;b=x;} else if (h<240){g=x;b=c;}
    else if (h<300){r=x;b=c;} else {r=c;b=x;}
    return [Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];
  }
  function colorFromIter(i, zr, zi){
    if (i>=MAX_ITER) return [0,0,0];
    if (!smoothChk.checked){
      const hue = 360 * i / MAX_ITER;
      return hsvToRgb(hue, 1, 1);
    }
    const mag = Math.hypot(zr, zi);
    const nu = Math.log2(Math.log(mag));
    const smooth = i + 1 - nu;
    const hue = 360 * (0.02 + 0.98 * (smooth / MAX_ITER));
    return hsvToRgb(hue, 1, 1);
  }

  // ===== Renderer =====
  let needsRender = true, rendering = false;
  function requestRender(){ needsRender = true; if (!rendering) render(); }

  async function render(){
    if (!needsRender) return;
    rendering = true; needsRender = false;

    const img = ctx.createImageData(canvas.width, canvas.height);
    const data = img.data;

    for (let y=0; y<canvas.height; y++){
      const cim = centerY + (y - canvas.height/2) / scale;
      let idx = y * canvas.width * 4;

      for (let x=0; x<canvas.width; x++){
        const cre = centerX + (x - canvas.width/2) / scale;
        let zr=0, zi=0, i=0;
        while (zr*zr + zi*zi <= 4 && i < MAX_ITER){
          const zr2 = zr*zr - zi*zi + cre;
          const zi2 = 2*zr*zi + cim;
          zr = zr2; zi = zi2; i++;
        }
        const [r,g,b] = colorFromIter(i, zr, zi);
        data[idx++] = r; data[idx++] = g; data[idx++] = b; data[idx++] = 255;
      }
      if (y % 24 === 0){
        ctx.putImageData(img, 0, 0);
        await new Promise(requestAnimationFrame);
        if (needsRender) break;
      }
    }
    ctx.putImageData(img, 0, 0);
    rendering = false;
    if (needsRender) render();
  }

  // Main tick for joystick motion
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.05, (now - last)/1000); // seconds, clamp for stability
    last = now;
    applyJoystick(dt);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // First draw
  render();
</script>
</body>
</html>