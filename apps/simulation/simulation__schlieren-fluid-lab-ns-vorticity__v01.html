<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Schlieren Fluid Simulation – Higher Fidelity</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #05070b;
      color: #f5f5f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      font-size: 1.4rem;
      margin: 1rem 0 0.25rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #e0e3ff;
    }

    p.subtitle {
      margin: 0 0 1rem;
      font-size: 0.9rem;
      color: #a0a4c0;
      text-align: center;
    }

    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem 1rem 2rem;
    }

    #view {
      border-radius: 16px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.65);
      background: #222;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.4rem;
      max-width: 720px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      justify-content: center;
      align-items: center;
    }

    button, select {
      background: #12141f;
      color: #e5e7ff;
      border: 1px solid #272a40;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s, border-color 0.15s;
    }

    button:hover, select:hover {
      background: #1a1e30;
      border-color: #4b57ff;
      box-shadow: 0 0 0 1px rgba(75, 87, 255, 0.3);
    }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: none;
    }

    button.active {
      background: #3038ff;
      border-color: #5c64ff;
      color: #fff;
      box-shadow: 0 0 0 1px rgba(92, 100, 255, 0.7);
    }

    .label {
      font-size: 0.75rem;
      color: #8489aa;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    input[type="range"] {
      width: 140px;
    }

    .hint {
      font-size: 0.75rem;
      color: #7b7f9a;
      margin-top: 0.25rem;
      text-align: center;
      max-width: 580px;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>Schlieren Fluid Lab (NS + Vorticity)</h1>
    <p class="subtitle">2D incompressible Navier–Stokes with vorticity confinement and schlieren rendering</p>

    <canvas id="view" width="640" height="640"></canvas>

    <div class="controls">
      <div class="row">
        <span class="label">Scenario</span>
        <button class="scenario-btn active" data-mode="none">Clear</button>
        <button class="scenario-btn" data-mode="match">Match plume</button>
        <button class="scenario-btn" data-mode="ignite">Match ignite</button>
        <button class="scenario-btn" data-mode="ice">Ice block</button>
        <button class="scenario-btn" data-mode="dryice">Dry ice</button>
      </div>
      <div class="row">
        <button id="whipBtn">Whip crack shock</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div class="row">
        <span class="label">Schlieren contrast</span>
        <input id="contrastSlider" type="range" min="5" max="60" value="25" />
      </div>
      <div class="row">
        <span class="label">Viscosity</span>
        <input id="viscSlider" type="range" min="0" max="40" value="5" />
      </div>
    </div>

    <p class="hint">
      Left-drag: hot rising jet. Right-drag (or Ctrl+drag): cold sinking jet. Higher contrast reveals finer gradients.
    </p>
  </div>

  <script>
    //================== Simulation parameters ==================
    const N = 128;            // internal grid resolution (N×N cells)
    const iter = 18;          // Poisson / diffusion iter
    let dt = 0.02;
    let viscBase = 0.00008;   // base viscosity
    const diffRho = 0.00002;  // density diffusion
    const diffT = 0.00005;    // temperature diffusion
    const ambientT = 0.0;
    const ambientRho = 0.0;

    // buoyancy coefficients (Boussinesq approximation)
    const buoyAlpha = -0.4;   // density contribution
    const buoyBeta  = 3.0;    // temperature contribution

    const vortEps = 0.4;      // vorticity confinement strength (tune visually)

    const size = (N + 2) * (N + 2);
    function IX(i, j) { return i + (N + 2) * j; }

    // Fields
    let u  = new Float32Array(size); // velocity x
    let v  = new Float32Array(size); // velocity y
    let u0 = new Float32Array(size);
    let v0 = new Float32Array(size);

    let rho   = new Float32Array(size); // "optical density" / mass
    let rho0  = new Float32Array(size);
    let temp  = new Float32Array(size);
    let temp0 = new Float32Array(size);

    // extra arrays for projection and vorticity
    let p   = new Float32Array(size);
    let div = new Float32Array(size);
    let omega   = new Float32Array(size); // vorticity
    let omegaMag = new Float32Array(size);

    //================== Low-level solver ==================
    function addSource(x, s, dt) {
      for (let i = 0; i < size; i++) x[i] += dt * s[i];
    }

    function setBnd(b, x) {
      for (let i = 1; i <= N; i++) {
        x[IX(0, i)]      = b === 1 ? -x[IX(1, i)]     : x[IX(1, i)];
        x[IX(N + 1, i)]  = b === 1 ? -x[IX(N, i)]     : x[IX(N, i)];
        x[IX(i, 0)]      = b === 2 ? -x[IX(i, 1)]     : x[IX(i, 1)];
        x[IX(i, N + 1)]  = b === 2 ? -x[IX(i, N)]     : x[IX(i, N)];
      }
      x[IX(0, 0)]           = 0.5 * (x[IX(1, 0)]        + x[IX(0, 1)]);
      x[IX(0, N + 1)]       = 0.5 * (x[IX(1, N + 1)]    + x[IX(0, N)]);
      x[IX(N + 1, 0)]       = 0.5 * (x[IX(N, 0)]        + x[IX(N + 1, 1)]);
      x[IX(N + 1, N + 1)]   = 0.5 * (x[IX(N, N + 1)]    + x[IX(N + 1, N)]);
    }

    function linSolve(b, x, x0, a, c) {
      for (let k = 0; k < iter; k++) {
        for (let j = 1; j <= N; j++) {
          for (let i = 1; i <= N; i++) {
            x[IX(i, j)] = (x0[IX(i, j)] +
              a * ( x[IX(i - 1, j)] + x[IX(i + 1, j)] +
                    x[IX(i, j - 1)] + x[IX(i, j + 1)] )
            ) / c;
          }
        }
        setBnd(b, x);
      }
    }

    function diffuse(b, x, x0, diff, dt) {
      const a = dt * diff * N * N;
      linSolve(b, x, x0, a, 1 + 4 * a);
    }

    function advect(b, d, d0, u, v, dt) {
      const dt0 = dt * N;
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          let x = i - dt0 * u[IX(i, j)];
          let y = j - dt0 * v[IX(i, j)];

          if (x < 0.5) x = 0.5;
          if (x > N + 0.5) x = N + 0.5;
          const i0 = Math.floor(x), i1 = i0 + 1;

          if (y < 0.5) y = 0.5;
          if (y > N + 0.5) y = N + 0.5;
          const j0 = Math.floor(y), j1 = j0 + 1;

          const s1 = x - i0, s0 = 1 - s1;
          const t1 = y - j0, t0 = 1 - t1;

          d[IX(i, j)] =
            s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
            s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
        }
      }
      setBnd(b, d);
    }

    function project(u, v, p, div) {
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          div[IX(i, j)] =
            -0.5 * (
              u[IX(i + 1, j)] - u[IX(i - 1, j)] +
              v[IX(i, j + 1)] - v[IX(i, j - 1)]
            ) / N;
          p[IX(i, j)] = 0;
        }
      }
      setBnd(0, div);
      setBnd(0, p);

      // IMPORTANT: solve ∇²p = div using div as RHS (not p itself)
      linSolve(0, p, div, 1, 4);

      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          u[IX(i, j)] -= 0.5 * N * (p[IX(i + 1, j)] - p[IX(i - 1, j)]);
          v[IX(i, j)] -= 0.5 * N * (p[IX(i, j + 1)] - p[IX(i, j - 1)]);
        }
      }
      setBnd(1, u);
      setBnd(2, v);
    }

    //================== Vorticity confinement ==================
    function computeVorticity() {
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          const dw_dy = (u[IX(i, j + 1)] - u[IX(i, j - 1)]) * 0.5;
          const du_dx = (v[IX(i + 1, j)] - v[IX(i - 1, j)]) * 0.5;
          const w = dw_dy - du_dx;      // scalar vorticity (z-component)
          omega[IX(i, j)] = w;
          omegaMag[IX(i, j)] = Math.abs(w);
        }
      }
      setBnd(0, omegaMag);
    }

    function applyVorticityConfinement(dt) {
      computeVorticity();
      const eps = vortEps;

      for (let j = 2; j <= N - 1; j++) {
        for (let i = 2; i <= N - 1; i++) {
          const idx = IX(i, j);
          const dw_dx = (omegaMag[IX(i + 1, j)] - omegaMag[IX(i - 1, j)]) * 0.5;
          const dw_dy = (omegaMag[IX(i, j + 1)] - omegaMag[IX(i, j - 1)]) * 0.5;

          let Nx = dw_dx, Ny = dw_dy;
          const len = Math.hypot(Nx, Ny) + 1e-6;
          Nx /= len; Ny /= len;

          const w = omega[idx];

          // F_conf = eps * (N × w_z) => (Fx, Fy) = eps * (Ny * w, -Nx * w)
          const Fx = eps * Ny * w;
          const Fy = -eps * Nx * w;

          u[idx] += Fx * dt;
          v[idx] += Fy * dt;
        }
      }
      setBnd(1, u);
      setBnd(2, v);
    }

    //================== Steps ==================
    function velStep(u, v, u0, v0, visc, dt) {
      addSource(u, u0, dt);
      addSource(v, v0, dt);

      [u0, u] = [u, u0]; diffuse(1, u, u0, visc, dt);
      [v0, v] = [v, v0]; diffuse(2, v, v0, visc, dt);

      project(u, v, p, div);

      [u0, u] = [u, u0];
      [v0, v] = [v, v0];
      advect(1, u, u0, u0, v0, dt);
      advect(2, v, v0, u0, v0, dt);

      applyVorticityConfinement(dt); // add swirling back in

      project(u, v, p, div);
    }

    function scalarStep(x, x0, u, v, diff, dt) {
      addSource(x, x0, dt);
      [x0, x] = [x, x0]; diffuse(0, x, x0, diff, dt);
      [x0, x] = [x, x0]; advect(0, x, x0, u, v, dt);
    }

    //================== Buoyancy ==================
    function addBuoyancy(dt) {
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          const idx = IX(i, j);
          const dRho = rho[idx] - ambientRho;
          const dT   = temp[idx] - ambientT;
          const F = buoyAlpha * dRho + buoyBeta * dT; // upward for hot / light
          v[idx] += F * dt;
        }
      }
      setBnd(2, v);
    }

    //================== Scenario sources ==================
    let mode = "none";
    let igniteFrame = 0;

    function zeroSources() {
      u0.fill(0);
      v0.fill(0);
      rho0.fill(0);
      temp0.fill(0);
    }

    function matchPlume() {
      const cx = Math.floor((N + 2) * 0.5);
      const baseY = 4;
      for (let j = baseY; j <= baseY + 4; j++) {
        for (let i = cx - 2; i <= cx + 2; i++) {
          const idx = IX(i, j);
          rho0[idx]  += 18.0;
          temp0[idx] += 80.0;
          v0[idx]    += 55.0;
        }
      }
    }

    function matchIgnite() {
      if (igniteFrame < 18) {
        const cx = Math.floor((N + 2) * 0.5);
        const cy = 10;
        const r = 10;
        for (let j = cy - r; j <= cy + r; j++) {
          for (let i = cx - r; i <= cx + r; i++) {
            const dx = i - cx, dy = j - cy;
            const d2 = dx * dx + dy * dy;
            if (d2 > r * r) continue;
            const fall = 1 - Math.sqrt(d2) / r;
            const idx = IX(i, j);
            temp0[idx] += 500.0 * fall;
            rho0[idx]  += 250.0 * fall;
            v0[idx]    += 180.0 * fall;
          }
        }
      }
      igniteFrame++;
      matchPlume();
    }

    function iceBlock() {
      const cx = Math.floor((N + 2) * 0.5);
      const cy = Math.floor((N + 2) * 0.5);
      const r = 12;
      for (let j = cy - r; j <= cy + r; j++) {
        for (let i = cx - r; i <= cx + r; i++) {
          const dx = i - cx, dy = j - cy;
          if (dx * dx + dy * dy > r * r) continue;
          const idx = IX(i, j);
          temp0[idx] -= 80.0;
        }
      }
    }

    function dryIce() {
      const cx = Math.floor((N + 2) * 0.5);
      const baseY = N - 4;
      const w = 18;
      for (let j = baseY - 4; j <= baseY; j++) {
        for (let i = cx - w; i <= cx + w; i++) {
          const idx = IX(i, j);
          temp0[idx] -= 100.0;
          rho0[idx]  += 60.0;  // heavier
          v0[idx]    -= 15.0;  // downward drift
        }
      }
    }

    function whipShock() {
      const cx = Math.floor((N + 2) * 0.32);
      const cy = Math.floor((N + 2) * 0.5);
      const r0 = 5;
      const r1 = 26;

      for (let j = 2; j <= N; j++) {
        for (let i = 2; i <= N; i++) {
          const dx = i - cx, dy = j - cy;
          const r = Math.hypot(dx, dy);
          if (r < r0 || r > r1) continue;
          const idx = IX(i, j);
          const normx = dx / (r + 1e-6);
          const normy = dy / (r + 1e-6);

          const fall = 1 - (r - r0) / (r1 - r0);
          const ampVel = 180.0 * fall;
          const ampRho = 180.0 * fall;
          const ampT   = 60.0  * fall;

          u0[idx]   += normx * ampVel;
          v0[idx]   += normy * ampVel;
          rho0[idx] += ampRho;
          temp0[idx] += ampT;
        }
      }
    }

    function applyScenarioSources() {
      if (mode === "match")      matchPlume();
      else if (mode === "ignite") matchIgnite();
      else if (mode === "ice")    iceBlock();
      else if (mode === "dryice") dryIce();
    }

    //================== Rendering (Schlieren) ==================
    const canvas = document.getElementById("view");
    const ctx2d  = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    let contrast = 25.0;

    function renderSchlieren() {
      const img = ctx2d.getImageData(0, 0, W, H);
      const data = img.data;
      const cellW = W / N;
      const cellH = H / N;

      // Refractive index proxy: n ~ f(rho, T)
      // We'll just use nField = a*rho - b*T and take gradient.
      const a = 1.0, b = 0.6;
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          const idx = IX(i, j);
          const nL = a * rho[IX(i - 1, j)] - b * temp[IX(i - 1, j)];
          const nR = a * rho[IX(i + 1, j)] - b * temp[IX(i + 1, j)];
          const nB = a * rho[IX(i, j - 1)] - b * temp[IX(i, j - 1)];
          const nT = a * rho[IX(i, j + 1)] - b * temp[IX(i, j + 1)];

          const gx = (nR - nL) * 0.5;
          const gy = (nT - nB) * 0.5;

          // knife-edge along x with slight tilt
          let I = 0.5 + (contrast / 255) * (gx - 0.4 * gy);
          if (I < 0) I = 0;
          if (I > 1) I = 1;
          const val = (I * 255) | 0;

          const x0 = Math.floor((i - 1) * cellW);
          const y0 = Math.floor((N - j) * cellH);
          const x1 = Math.floor(i * cellW);
          const y1 = Math.floor((N - j + 1) * cellH);

          for (let py = y0; py < y1; py++) {
            for (let px = x0; px < x1; px++) {
              const p = (px + py * W) * 4;
              data[p]     = val;
              data[p + 1] = val;
              data[p + 2] = val;
              data[p + 3] = 255;
            }
          }
        }
      }
      ctx2d.putImageData(img, 0, 0);
    }

    //================== Interaction ==================
    let mouseDown = false;
    let mouseButton = 0;

    canvas.addEventListener("mousedown", (e) => {
      mouseDown = true;
      mouseButton = e.button;
    });
    window.addEventListener("mouseup", () => { mouseDown = false; });

    canvas.addEventListener("mousemove", (e) => {
      if (!mouseDown) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const i = Math.floor((x / W) * N) + 1;
      const j = N - Math.floor((y / H) * N);
      if (i < 1 || i > N || j < 1 || j > N) return;

      const hot = (mouseButton === 0 && !e.ctrlKey && !e.metaKey) ? 1 : 0;
      const cold = (mouseButton === 2 || e.ctrlKey || e.metaKey) ? 1 : 0;

      const r = 5;
      for (let jj = j - r; jj <= j + r; jj++) {
        for (let ii = i - r; ii <= i + r; ii++) {
          if (ii < 1 || ii > N || jj < 1 || jj > N) continue;
          const dx = ii - i, dy = jj - j;
          const d2 = dx * dx + dy * dy;
          if (d2 > r * r) continue;
          const w = 1 - Math.sqrt(d2) / r;
          const idx = IX(ii, jj);
          if (hot) {
            temp0[idx] += 150 * w;
            rho0[idx]  += 40  * w;
            v0[idx]    += 40  * w;
          }
          if (cold) {
            temp0[idx] -= 150 * w;
            rho0[idx]  += 40  * w;
            v0[idx]    -= 40  * w;
          }
        }
      }
    });

    // disable default right-click menu on canvas
    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    //================== UI controls ==================
    const scenarioBtns = Array.from(document.querySelectorAll(".scenario-btn"));
    const whipBtn = document.getElementById("whipBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const contrastSlider = document.getElementById("contrastSlider");
    const viscSlider = document.getElementById("viscSlider");

    let paused = false;

    function setMode(m) {
      mode = m;
      if (m === "ignite") igniteFrame = 0;
      scenarioBtns.forEach(btn => {
        btn.classList.toggle("active", btn.dataset.mode === m);
      });
    }

    scenarioBtns.forEach(btn => {
      btn.addEventListener("click", () => setMode(btn.dataset.mode));
    });

    whipBtn.addEventListener("click", () => whipShock());

    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "Play" : "Pause";
    });

    resetBtn.addEventListener("click", () => {
      u.fill(0); v.fill(0); u0.fill(0); v0.fill(0);
      rho.fill(0); rho0.fill(0);
      temp.fill(0); temp0.fill(0);
      omega.fill(0); omegaMag.fill(0);
      p.fill(0); div.fill(0);
      setMode("none");
    });

    contrastSlider.addEventListener("input", () => {
      contrast = Number(contrastSlider.value);
    });

    viscSlider.addEventListener("input", () => {
      const x = Number(viscSlider.value) / 40; // 0..1
      viscBase = 0.00001 + x * x * 0.0004;    // non-linear for smoother control
    });

    //================== Main loop ==================
    function step() {
      if (!paused) {
        zeroSources();
        applyScenarioSources();

        const visc = viscBase;
        velStep(u, v, u0, v0, visc, dt);
        scalarStep(rho,  rho0,  u, v, diffRho, dt);
        scalarStep(temp, temp0, u, v, diffT, dt);
        addBuoyancy(dt);
      }
      renderSchlieren();
      requestAnimationFrame(step);
    }

    renderSchlieren();
    requestAnimationFrame(step);
  </script>
</body>
</html>
 